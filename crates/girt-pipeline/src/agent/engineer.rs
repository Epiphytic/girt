use crate::error::PipelineError;
use crate::llm::{LlmClient, LlmMessage, LlmRequest, TokenUsage};
use crate::types::{BugTicket, BuildOutput, ImplementationPlan, PolicyYaml, RefinedSpec, TargetLanguage};

const ENGINEER_RUST_PROMPT: &str = r#"You are a Senior Backend Engineer. You write functions that compile to wasm32-wasi Components and run inside girt-runtime, a Wasmtime-based WASM sandbox.

Target: Rust -> WebAssembly Component Model via cargo-component v0.21.

Your code MUST follow the cargo-component v0.21 bindings pattern:
1. Include `#[allow(warnings)] mod bindings;` (auto-generated by cargo-component)
2. Import `bindings::Guest`
3. Implement the `Guest` trait on a `Component` struct
4. Export via `bindings::export!(Component with_types_in bindings);`
5. The WIT world is named `girt-tool` with: `export run: func(input: string) -> result<string, string>;`

The `run` function receives a JSON string as input and returns a JSON string as output (or an error string).

EXAMPLE source_code (use this pattern EXACTLY):
```
#[allow(warnings)]
mod bindings;

use bindings::Guest;

struct Component;

impl Guest for Component {
    fn run(input: String) -> Result<String, String> {
        let parsed: serde_json::Value = serde_json::from_str(&input)
            .map_err(|e| format!("Invalid input: {e}"))?;
        let result = serde_json::json!({"result": "value"});
        serde_json::to_string(&result).map_err(|e| format!("Serialization error: {e}"))
    }
}

bindings::export!(Component with_types_in bindings);
```

EXAMPLE wit_definition (use this EXACTLY, do NOT modify):
```
package girt:tool;

world girt-tool {
    export run: func(input: string) -> result<string, string>;
}
```

Environment Constraints:
- No local filesystem access unless explicitly granted in the spec.
- No native network access. Use WASI HTTP for outbound calls.
- Network access is restricted to hosts listed in the spec's constraints.
- SECRETS: Never hardcode credentials. Call host_auth_proxy(service_name) to get authenticated responses.
- Available crate dependencies: serde, serde_json (wit-bindgen-rt is already included).

Long-Running Operations — Continue-Signal Pattern (GIRT convention):
If the spec involves waiting, polling, or monitoring (e.g. "wait for approval",
"poll until complete", "retry for up to 2 days"), you MUST implement the
continue-signal pattern. Never implement a blocking loop for the full duration.

Rules:
- Per-invocation wall-clock budget: ≤60 seconds total. Hard limit.
- Fixed poll interval: 5–15 seconds. Do NOT vary it — backoff is the caller's job.
- Maximum polls per invocation = budget ÷ interval (e.g. 60s / 10s = 6 iterations).
- If the operation is not complete when the budget expires, return immediately
  with status="pending" and a RESUME TOKEN (the identifier needed to pick up
  where you left off — e.g. message_id, job_id, cursor).
- The input struct must have an optional resume token field. On re-invocation
  (token present), skip setup (skip posting, skip job creation) and go straight
  to checking status.
- The output struct must always include: status (string: "pending" or a terminal
  value like "approved"/"denied") and the resume token.
- The caller owns the retry loop, overall deadline, and backoff. The WASM has
  no opinion on how many times it will be re-invoked.

Output ONLY valid JSON in this exact format:
{
  "source_code": "// Full Rust source code using the bindings pattern shown above",
  "wit_definition": "package girt:tool;\n\nworld girt-tool {\n    export run: func(input: string) -> result<string, string>;\n}",
  "policy_yaml": "// girt-runtime network policy (list allowed hosts, e.g. '- example.com')",
  "language": "rust"
}

Do not include any text outside the JSON object. Do not use markdown code fences."#;

const ENGINEER_GO_PROMPT: &str = r#"You are a Senior Backend Engineer. You write functions that compile to wasm32-wasi Components using TinyGo and run inside girt-runtime, a Wasmtime-based WASM sandbox.

Target: Go (TinyGo) -> WebAssembly Component Model with WIT interface definitions.

TinyGo Constraints:
- Use TinyGo-compatible standard library only. No cgo, no unsafe, no reflect.
- Import "unsafe" is forbidden.
- Use wasi-go bindings for WASI interfaces.
- Keep allocations minimal; TinyGo has a simple GC.

Environment Constraints:
- No local filesystem access unless explicitly granted in the spec.
- No native network access. Use WASI HTTP for outbound calls.
- Network access is restricted to hosts listed in the spec's constraints.
- SECRETS: Never hardcode credentials. Call host_auth_proxy(service_name) to get authenticated responses.

Output ONLY valid JSON in this exact format:
{
  "source_code": "// Full Go source code here",
  "wit_definition": "// WIT interface here",
  "policy_yaml": "// girt-runtime network policy (list allowed hosts)",
  "language": "go"
}

Do not include any text outside the JSON object. Do not use markdown code fences."#;

const ENGINEER_AS_PROMPT: &str = r#"You are a Senior Backend Engineer. You write functions that compile to wasm32-wasi Components using AssemblyScript and run inside girt-runtime, a Wasmtime-based WASM sandbox.

Target: AssemblyScript -> WebAssembly Component Model with WIT interface definitions.

AssemblyScript Constraints:
- Use AssemblyScript standard library (as-*).
- No dynamic imports or eval.
- Use typed arrays and explicit memory management.
- Prefer static dispatch over dynamic dispatch.

Environment Constraints:
- No local filesystem access unless explicitly granted in the spec.
- No native network access. Use WASI HTTP for outbound calls.
- Network access is restricted to hosts listed in the spec's constraints.
- SECRETS: Never hardcode credentials. Call host_auth_proxy(service_name) to get authenticated responses.

Output ONLY valid JSON in this exact format:
{
  "source_code": "// Full AssemblyScript source code here",
  "wit_definition": "// WIT interface here",
  "policy_yaml": "// girt-runtime network policy (list allowed hosts)",
  "language": "assemblyscript"
}

Do not include any text outside the JSON object. Do not use markdown code fences."#;

const ENGINEER_FIX_PROMPT: &str = r#"You previously built a WASM component that had issues. Fix the code based on the bug ticket below.

Output ONLY the complete fixed code in the same JSON format as before:
{
  "source_code": "// Fixed source code",
  "wit_definition": "// WIT interface (may be unchanged)",
  "policy_yaml": "// girt-runtime network policy (may be unchanged)",
  "language": "<same language as before>"
}"#;

/// The Engineer agent generates WASM Component source code from the
/// Architect's refined spec. Supports Rust, Go (TinyGo), and AssemblyScript targets.
pub struct EngineerAgent<'a> {
    llm: &'a dyn LlmClient,
    target: TargetLanguage,
    /// Optional coding standards injected into every system prompt.
    /// Loaded from `pipeline.coding_standards_path` in girt.toml.
    coding_standards: Option<String>,
    /// Token budget for LLM responses. Complex WASM components need 8000+.
    max_tokens: u32,
    /// Optional implementation plan from the Planner agent. When present,
    /// injected into the build and fix prompts as the authoritative reference.
    implementation_plan: Option<ImplementationPlan>,
}

impl<'a> EngineerAgent<'a> {
    pub fn new(llm: &'a dyn LlmClient) -> Self {
        Self {
            llm,
            target: TargetLanguage::default(),
            coding_standards: None,
            max_tokens: 64000,
            implementation_plan: None,
        }
    }

    pub fn with_target(llm: &'a dyn LlmClient, target: TargetLanguage) -> Self {
        Self {
            llm,
            target,
            coding_standards: None,
            max_tokens: 64000,
            implementation_plan: None,
        }
    }

    /// Attach coding standards to be injected into the system prompt.
    pub fn with_standards(mut self, standards: Option<String>) -> Self {
        self.coding_standards = standards;
        self
    }

    /// Override the token budget (default: 8192).
    pub fn with_max_tokens(mut self, max_tokens: u32) -> Self {
        self.max_tokens = max_tokens;
        self
    }

    /// Attach an implementation plan from the Planner agent.
    ///
    /// When set, the plan is injected into every build and fix prompt as the
    /// authoritative implementation reference. The Engineer must follow the
    /// plan's validation strategy and API sequence.
    pub fn with_plan(mut self, plan: Option<ImplementationPlan>) -> Self {
        self.implementation_plan = plan;
        self
    }

    /// Build the full system prompt for the current target, optionally appending
    /// coding standards so the Engineer follows the project's conventions.
    fn system_prompt(&self) -> String {
        let base = match self.target {
            TargetLanguage::Rust => ENGINEER_RUST_PROMPT,
            TargetLanguage::Go => ENGINEER_GO_PROMPT,
            TargetLanguage::AssemblyScript => ENGINEER_AS_PROMPT,
        };
        match &self.coding_standards {
            Some(standards) => format!(
                "{base}\n\n## Project Coding Standards\n\
                 The following standards apply to all code you write. Follow them:\n\n\
                 {standards}"
            ),
            None => base.to_string(),
        }
    }

    /// Build the fix system prompt, also injecting coding standards if present.
    fn fix_prompt(&self) -> String {
        match &self.coding_standards {
            Some(standards) => format!(
                "{ENGINEER_FIX_PROMPT}\n\n## Project Coding Standards\n\
                 The following standards apply. Follow them:\n\n\
                 {standards}"
            ),
            None => ENGINEER_FIX_PROMPT.to_string(),
        }
    }

    /// Format the implementation plan section for injection into prompts.
    fn plan_section(&self) -> Option<String> {
        self.implementation_plan.as_ref().map(|plan| {
            format!(
                "\n\nImplementation Plan (authoritative — follow exactly; note any deviation in a code comment):\n\
                 Validation Layer: {}\n\
                 Security Notes: {}\n\
                 API Sequence: {}\n\
                 Edge Cases: {}\n\
                 Implementation Guidance: {}",
                plan.validation_layer,
                plan.security_notes,
                plan.api_sequence,
                plan.edge_cases,
                plan.implementation_guidance,
            )
        })
    }

    /// Generate initial code from a refined spec.
    pub async fn build(&self, spec: &RefinedSpec) -> Result<(BuildOutput, TokenUsage), PipelineError> {
        let spec_json = serde_json::to_string_pretty(spec)
            .map_err(|e| PipelineError::LlmError(format!("Failed to serialize spec: {e}")))?;

        let plan_text = self.plan_section().unwrap_or_default();
        let content = format!(
            "Implement this tool spec as a WASM Component:{plan_text}\n\nSpec:\n{spec_json}"
        );

        let request = LlmRequest {
            system_prompt: self.system_prompt(),
            messages: vec![LlmMessage {
                role: "user".into(),
                content,
            }],
            max_tokens: self.max_tokens,
        };

        let response = self.llm.chat(&request).await?;
        let usage = response.usage.clone();
        let output = self.parse_build_output(&response.content, spec)?;
        Ok((output, usage))
    }

    /// Fix code based on a bug ticket.
    pub async fn fix(
        &self,
        spec: &RefinedSpec,
        previous_output: &BuildOutput,
        ticket: &BugTicket,
    ) -> Result<(BuildOutput, TokenUsage), PipelineError> {
        let ticket_json = serde_json::to_string_pretty(ticket)
            .map_err(|e| PipelineError::LlmError(format!("Failed to serialize ticket: {e}")))?;

        let plan_text = self.plan_section().unwrap_or_default();
        let content = format!(
            "Original spec:\n{}{plan_text}\n\nPrevious code:\n{}\n\nBug ticket:\n{}",
            serde_json::to_string_pretty(spec).unwrap_or_default(),
            previous_output.source_code,
            ticket_json,
        );

        let request = LlmRequest {
            system_prompt: self.fix_prompt(),
            messages: vec![LlmMessage {
                role: "user".into(),
                content,
            }],
            max_tokens: self.max_tokens,
        };

        let response = self.llm.chat(&request).await?;
        let usage = response.usage.clone();
        let output = self.parse_build_output(&response.content, spec)?;
        Ok((output, usage))
    }

    fn parse_build_output(
        &self,
        raw: &str,
        spec: &RefinedSpec,
    ) -> Result<BuildOutput, PipelineError> {
        // Try extracting JSON (handles code fences and surrounding text)
        if let Some(output) = super::extract_json::<BuildOutput>(raw) {
            return Ok(output);
        }

        // If JSON extraction fails, generate a policy.yaml from the spec and
        // treat the response as raw source code with default WIT.
        let policy = PolicyYaml::from_spec(&spec.spec);
        let policy_yaml = serde_json::to_string_pretty(&policy).unwrap_or_default();

        tracing::warn!(
            language = %self.target,
            "Engineer response was not valid JSON, treating as raw source code"
        );
        Ok(BuildOutput {
            source_code: raw.to_string(),
            wit_definition: "package girt:tool;\n\nworld girt-tool {\n    export run: func(input: string) -> result<string, string>;\n}\n".to_string(),
            policy_yaml,
            language: self.target.to_string(),
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::llm::StubLlmClient;
    use crate::types::SpecAction;
    use girt_core::spec::{CapabilityConstraints, CapabilitySpec};

    fn make_refined_spec() -> RefinedSpec {
        RefinedSpec {
            action: SpecAction::Build,
            spec: CapabilitySpec {
                name: "temp_convert".into(),
                description: "Convert temperature units".into(),
                inputs: serde_json::json!({"value": "f64", "from": "string", "to": "string"}),
                outputs: serde_json::json!({"result": "f64"}),
                constraints: CapabilityConstraints::default(),
            },
            design_notes: "Simple stateless conversion".into(),
            extend_target: None,
            extend_features: None,
            complexity_hint: None,
        }
    }

    #[tokio::test]
    async fn builds_from_valid_json_response() {
        let response = serde_json::json!({
            "source_code": "fn convert(value: f64) -> f64 { value * 1.8 + 32.0 }",
            "wit_definition": "package temp:convert;",
            "policy_yaml": "version: \"1.0\"",
            "language": "rust"
        });

        let client = StubLlmClient::constant(&response.to_string());
        let agent = EngineerAgent::new(&client);
        let spec = make_refined_spec();

        let (output, _) = agent.build(&spec).await.unwrap();
        assert_eq!(output.language, "rust");
        assert!(output.source_code.contains("convert"));
    }

    #[tokio::test]
    async fn handles_non_json_response_gracefully() {
        let client = StubLlmClient::constant("fn convert() { /* raw code */ }");
        let agent = EngineerAgent::new(&client);
        let spec = make_refined_spec();

        let (output, _) = agent.build(&spec).await.unwrap();
        assert!(output.source_code.contains("raw code"));
        assert_eq!(output.language, "rust");
    }

    #[tokio::test]
    async fn go_target_uses_go_language() {
        let client = StubLlmClient::constant("package main\nfunc convert() {}");
        let agent = EngineerAgent::with_target(&client, TargetLanguage::Go);
        let spec = make_refined_spec();

        let (output, _) = agent.build(&spec).await.unwrap();
        assert_eq!(output.language, "go");
        assert!(output.source_code.contains("package main"));
    }

    #[tokio::test]
    async fn assemblyscript_target_uses_as_language() {
        let client = StubLlmClient::constant("export function convert(): f64 { return 0; }");
        let agent = EngineerAgent::with_target(&client, TargetLanguage::AssemblyScript);
        let spec = make_refined_spec();

        let (output, _) = agent.build(&spec).await.unwrap();
        assert_eq!(output.language, "assemblyscript");
    }

    #[tokio::test]
    async fn go_json_response_parses_correctly() {
        let response = serde_json::json!({
            "source_code": "package main\nfunc Convert(v float64) float64 { return v * 1.8 + 32.0 }",
            "wit_definition": "package temp:convert;",
            "policy_yaml": "version: \"1.0\"",
            "language": "go"
        });

        let client = StubLlmClient::constant(&response.to_string());
        let agent = EngineerAgent::with_target(&client, TargetLanguage::Go);
        let spec = make_refined_spec();

        let (output, _) = agent.build(&spec).await.unwrap();
        assert_eq!(output.language, "go");
        assert!(output.source_code.contains("Convert"));
    }
}
