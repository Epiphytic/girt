use crate::error::PipelineError;
use crate::llm::{LlmClient, LlmMessage, LlmRequest};
use crate::types::{BugTicket, BuildOutput, PolicyYaml, RefinedSpec, TargetLanguage};

const ENGINEER_RUST_PROMPT: &str = r#"You are a Senior Backend Engineer. You write functions that compile to wasm32-wasi Components and run inside girt-runtime, a Wasmtime-based WASM sandbox.

Target: Rust -> WebAssembly Component Model via cargo-component v0.21.

Your code MUST follow the cargo-component v0.21 bindings pattern:
1. Include `#[allow(warnings)] mod bindings;` (auto-generated by cargo-component)
2. Import `bindings::Guest`
3. Implement the `Guest` trait on a `Component` struct
4. Export via `bindings::export!(Component with_types_in bindings);`
5. The WIT world is named `girt-tool` with: `export run: func(input: string) -> result<string, string>;`

The `run` function receives a JSON string as input and returns a JSON string as output (or an error string).

EXAMPLE source_code (use this pattern EXACTLY):
```
#[allow(warnings)]
mod bindings;

use bindings::Guest;

struct Component;

impl Guest for Component {
    fn run(input: String) -> Result<String, String> {
        let parsed: serde_json::Value = serde_json::from_str(&input)
            .map_err(|e| format!("Invalid input: {e}"))?;
        let result = serde_json::json!({"result": "value"});
        serde_json::to_string(&result).map_err(|e| format!("Serialization error: {e}"))
    }
}

bindings::export!(Component with_types_in bindings);
```

EXAMPLE wit_definition (use this EXACTLY, do NOT modify):
```
package girt:tool;

world girt-tool {
    export run: func(input: string) -> result<string, string>;
}
```

Environment Constraints:
- No local filesystem access unless explicitly granted in the spec.
- No native network access. Use WASI HTTP for outbound calls.
- Network access is restricted to hosts listed in the spec's constraints.
- SECRETS: Never hardcode credentials. Call host_auth_proxy(service_name) to get authenticated responses.
- Available crate dependencies: serde, serde_json (wit-bindgen-rt is already included).

Output ONLY valid JSON in this exact format:
{
  "source_code": "// Full Rust source code using the bindings pattern shown above",
  "wit_definition": "package girt:tool;\n\nworld girt-tool {\n    export run: func(input: string) -> result<string, string>;\n}",
  "policy_yaml": "// girt-runtime network policy (list allowed hosts, e.g. '- example.com')",
  "language": "rust"
}

Do not include any text outside the JSON object. Do not use markdown code fences."#;

const ENGINEER_GO_PROMPT: &str = r#"You are a Senior Backend Engineer. You write functions that compile to wasm32-wasi Components using TinyGo and run inside girt-runtime, a Wasmtime-based WASM sandbox.

Target: Go (TinyGo) -> WebAssembly Component Model with WIT interface definitions.

TinyGo Constraints:
- Use TinyGo-compatible standard library only. No cgo, no unsafe, no reflect.
- Import "unsafe" is forbidden.
- Use wasi-go bindings for WASI interfaces.
- Keep allocations minimal; TinyGo has a simple GC.

Environment Constraints:
- No local filesystem access unless explicitly granted in the spec.
- No native network access. Use WASI HTTP for outbound calls.
- Network access is restricted to hosts listed in the spec's constraints.
- SECRETS: Never hardcode credentials. Call host_auth_proxy(service_name) to get authenticated responses.

Output ONLY valid JSON in this exact format:
{
  "source_code": "// Full Go source code here",
  "wit_definition": "// WIT interface here",
  "policy_yaml": "// girt-runtime network policy (list allowed hosts)",
  "language": "go"
}

Do not include any text outside the JSON object. Do not use markdown code fences."#;

const ENGINEER_AS_PROMPT: &str = r#"You are a Senior Backend Engineer. You write functions that compile to wasm32-wasi Components using AssemblyScript and run inside girt-runtime, a Wasmtime-based WASM sandbox.

Target: AssemblyScript -> WebAssembly Component Model with WIT interface definitions.

AssemblyScript Constraints:
- Use AssemblyScript standard library (as-*).
- No dynamic imports or eval.
- Use typed arrays and explicit memory management.
- Prefer static dispatch over dynamic dispatch.

Environment Constraints:
- No local filesystem access unless explicitly granted in the spec.
- No native network access. Use WASI HTTP for outbound calls.
- Network access is restricted to hosts listed in the spec's constraints.
- SECRETS: Never hardcode credentials. Call host_auth_proxy(service_name) to get authenticated responses.

Output ONLY valid JSON in this exact format:
{
  "source_code": "// Full AssemblyScript source code here",
  "wit_definition": "// WIT interface here",
  "policy_yaml": "// girt-runtime network policy (list allowed hosts)",
  "language": "assemblyscript"
}

Do not include any text outside the JSON object. Do not use markdown code fences."#;

const ENGINEER_FIX_PROMPT: &str = r#"You previously built a WASM component that had issues. Fix the code based on the bug ticket below.

Output ONLY the complete fixed code in the same JSON format as before:
{
  "source_code": "// Fixed source code",
  "wit_definition": "// WIT interface (may be unchanged)",
  "policy_yaml": "// girt-runtime network policy (may be unchanged)",
  "language": "<same language as before>"
}"#;

/// The Engineer agent generates WASM Component source code from the
/// Architect's refined spec. Supports Rust, Go (TinyGo), and AssemblyScript targets.
pub struct EngineerAgent<'a> {
    llm: &'a dyn LlmClient,
    target: TargetLanguage,
}

impl<'a> EngineerAgent<'a> {
    pub fn new(llm: &'a dyn LlmClient) -> Self {
        Self {
            llm,
            target: TargetLanguage::default(),
        }
    }

    pub fn with_target(llm: &'a dyn LlmClient, target: TargetLanguage) -> Self {
        Self { llm, target }
    }

    /// Get the system prompt for the configured target language.
    fn system_prompt(&self) -> &'static str {
        match self.target {
            TargetLanguage::Rust => ENGINEER_RUST_PROMPT,
            TargetLanguage::Go => ENGINEER_GO_PROMPT,
            TargetLanguage::AssemblyScript => ENGINEER_AS_PROMPT,
        }
    }

    /// Generate initial code from a refined spec.
    pub async fn build(&self, spec: &RefinedSpec) -> Result<BuildOutput, PipelineError> {
        let spec_json = serde_json::to_string_pretty(spec)
            .map_err(|e| PipelineError::LlmError(format!("Failed to serialize spec: {e}")))?;

        let request = LlmRequest {
            system_prompt: self.system_prompt().into(),
            messages: vec![LlmMessage {
                role: "user".into(),
                content: format!("Implement this tool spec as a WASM Component:\n\n{spec_json}"),
            }],
            max_tokens: 4000,
        };

        let response = self.llm.chat(&request).await?;
        self.parse_build_output(&response.content, spec)
    }

    /// Fix code based on a bug ticket.
    pub async fn fix(
        &self,
        spec: &RefinedSpec,
        previous_output: &BuildOutput,
        ticket: &BugTicket,
    ) -> Result<BuildOutput, PipelineError> {
        let ticket_json = serde_json::to_string_pretty(ticket)
            .map_err(|e| PipelineError::LlmError(format!("Failed to serialize ticket: {e}")))?;

        let request = LlmRequest {
            system_prompt: ENGINEER_FIX_PROMPT.into(),
            messages: vec![LlmMessage {
                role: "user".into(),
                content: format!(
                    "Original spec:\n{}\n\nPrevious code:\n{}\n\nBug ticket:\n{}",
                    serde_json::to_string_pretty(spec).unwrap_or_default(),
                    previous_output.source_code,
                    ticket_json,
                ),
            }],
            max_tokens: 4000,
        };

        let response = self.llm.chat(&request).await?;
        self.parse_build_output(&response.content, spec)
    }

    fn parse_build_output(
        &self,
        raw: &str,
        spec: &RefinedSpec,
    ) -> Result<BuildOutput, PipelineError> {
        // Try extracting JSON (handles code fences and surrounding text)
        if let Some(output) = super::extract_json::<BuildOutput>(raw) {
            return Ok(output);
        }

        // If JSON extraction fails, generate a policy.yaml from the spec and
        // treat the response as raw source code with default WIT.
        let policy = PolicyYaml::from_spec(&spec.spec);
        let policy_yaml = serde_json::to_string_pretty(&policy).unwrap_or_default();

        tracing::warn!(
            language = %self.target,
            "Engineer response was not valid JSON, treating as raw source code"
        );
        Ok(BuildOutput {
            source_code: raw.to_string(),
            wit_definition: "package girt:tool;\n\nworld girt-tool {\n    export run: func(input: string) -> result<string, string>;\n}\n".to_string(),
            policy_yaml,
            language: self.target.to_string(),
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::llm::StubLlmClient;
    use crate::types::SpecAction;
    use girt_core::spec::{CapabilityConstraints, CapabilitySpec};

    fn make_refined_spec() -> RefinedSpec {
        RefinedSpec {
            action: SpecAction::Build,
            spec: CapabilitySpec {
                name: "temp_convert".into(),
                description: "Convert temperature units".into(),
                inputs: serde_json::json!({"value": "f64", "from": "string", "to": "string"}),
                outputs: serde_json::json!({"result": "f64"}),
                constraints: CapabilityConstraints::default(),
            },
            design_notes: "Simple stateless conversion".into(),
            extend_target: None,
            extend_features: None,
        }
    }

    #[tokio::test]
    async fn builds_from_valid_json_response() {
        let response = serde_json::json!({
            "source_code": "fn convert(value: f64) -> f64 { value * 1.8 + 32.0 }",
            "wit_definition": "package temp:convert;",
            "policy_yaml": "version: \"1.0\"",
            "language": "rust"
        });

        let client = StubLlmClient::constant(&response.to_string());
        let agent = EngineerAgent::new(&client);
        let spec = make_refined_spec();

        let output = agent.build(&spec).await.unwrap();
        assert_eq!(output.language, "rust");
        assert!(output.source_code.contains("convert"));
    }

    #[tokio::test]
    async fn handles_non_json_response_gracefully() {
        let client = StubLlmClient::constant("fn convert() { /* raw code */ }");
        let agent = EngineerAgent::new(&client);
        let spec = make_refined_spec();

        let output = agent.build(&spec).await.unwrap();
        assert!(output.source_code.contains("raw code"));
        assert_eq!(output.language, "rust");
    }

    #[tokio::test]
    async fn go_target_uses_go_language() {
        let client = StubLlmClient::constant("package main\nfunc convert() {}");
        let agent = EngineerAgent::with_target(&client, TargetLanguage::Go);
        let spec = make_refined_spec();

        let output = agent.build(&spec).await.unwrap();
        assert_eq!(output.language, "go");
        assert!(output.source_code.contains("package main"));
    }

    #[tokio::test]
    async fn assemblyscript_target_uses_as_language() {
        let client = StubLlmClient::constant("export function convert(): f64 { return 0; }");
        let agent = EngineerAgent::with_target(&client, TargetLanguage::AssemblyScript);
        let spec = make_refined_spec();

        let output = agent.build(&spec).await.unwrap();
        assert_eq!(output.language, "assemblyscript");
    }

    #[tokio::test]
    async fn go_json_response_parses_correctly() {
        let response = serde_json::json!({
            "source_code": "package main\nfunc Convert(v float64) float64 { return v * 1.8 + 32.0 }",
            "wit_definition": "package temp:convert;",
            "policy_yaml": "version: \"1.0\"",
            "language": "go"
        });

        let client = StubLlmClient::constant(&response.to_string());
        let agent = EngineerAgent::with_target(&client, TargetLanguage::Go);
        let spec = make_refined_spec();

        let output = agent.build(&spec).await.unwrap();
        assert_eq!(output.language, "go");
        assert!(output.source_code.contains("Convert"));
    }
}
